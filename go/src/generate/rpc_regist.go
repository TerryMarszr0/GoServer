package main

import (
	"bytes"
	"common"
	"fmt"
	"os"
	"regexp"
	"strings"
	"text/template"
)

const (
	K_RegistOutDir   = K_OutDir
	K_RegistFileName = "generate_rpc.go"
)

func generatRpcRegist(svr string) {
	names, _ := common.WalkDir(K_SvrDir+svr, ".go")
	pinfo := &RpcInfo{Svr: svr, Moudles: make(map[string]bool, 8)}

	var tcpRpcs, httpRpcs, httpPlayerRpcs, httpHandles bytes.Buffer

	for _, v := range names {
		moudle := "" //package name
		common.ReadLine(v, func(line string) {
			fname := "" //func name
			if fname = getPackage(line); fname != "" {
				moudle = fname
				fname = ""
			} else if fname = getTcpRpc(line); fname != "" {
				tcpRpcs.WriteString(makeRegistId(moudle, fname))
			} else if fname = getHttpRpc(line); fname != "" {
				httpRpcs.WriteString(makeRegistId(moudle, fname))
			} else if fname = getHttpPlayerRpc(line); fname != "" {
				httpPlayerRpcs.WriteString(makeRegistId(moudle, fname))
			} else if fname = getHttpHandle(line); fname != "" {
				httpHandles.WriteString(makeRegistStr(moudle, fname))
			}
			if moudle != "" && fname != "" {
				pinfo.Moudles[moudle] = true
			}
		})
	}
	pinfo.RegistList = makeRegistList(&tcpRpcs, &httpRpcs, &httpPlayerRpcs, &httpHandles)
	pinfo.makeFile(svr)
}

// -------------------------------------
// -- 提取包名、Rpc函数名
func getPackage(s string) string {
	if ok, _ := regexp.MatchString(`^package \w+$`, s); ok {
		reg := regexp.MustCompile(`\w+`)
		return reg.FindAllString(s, -1)[1]
	}
	return ""
}
func getTcpRpc(s string) string {
	if ok, _ := regexp.MatchString(`^func Rpc_\w+\(\w+, \w+ \*common.NetPack, \w+ \*tcp.TCPConn\) \{$`, s); ok {
		reg := regexp.MustCompile(`Rpc_\w+`)
		return reg.FindAllString(s, -1)[0]
	}
	return ""
}
func getHttpRpc(s string) string {
	if ok, _ := regexp.MatchString(`^func Rpc_\w+\(\w+, \w+ \*common.NetPack\) \{$`, s); ok {
		reg := regexp.MustCompile(`Rpc_\w+`)
		return reg.FindAllString(s, -1)[0]
	}
	return ""
}
func getHttpPlayerRpc(s string) string {
	if ok, _ := regexp.MatchString(`^func Rpc_\w+\(\w+, \w+ \*common.NetPack, \w+ interface\{\}\) \{$`, s); ok {
		reg := regexp.MustCompile(`Rpc_\w+`)
		return reg.FindAllString(s, -1)[0]
	}
	return ""
}
func getHttpHandle(s string) string {
	if ok, _ := regexp.MatchString(`^func Rpc_\w+\(\w+ http.ResponseWriter, \w+ \*http.Request\) \{$`, s); ok {
		reg := regexp.MustCompile(`Rpc_\w+`)
		return reg.FindAllString(s, -1)[0]
	}
	return ""
}

// -------------------------------------
// -- 生成注册语句
func makeRegistId(moudle, fname string) string {
	return fmt.Sprintf("enum.%s: %s.%s,\n", fname, moudle, fname)
}
func makeRegistStr(moudle, fname string) string {
	return fmt.Sprintf("\"%s\": %s.%s,\n", strings.ToLower(fname), moudle, fname)
}
func makeRegistList(tcpRpcs, httpRpcs, httpPlayerRpcs, httpHandles *bytes.Buffer) string {
	var buf bytes.Buffer

	buf.WriteString("netConfig.RegTcpRpc(map[uint16]netConfig.TcpRpc{\n")
	buf.WriteString(tcpRpcs.String())
	buf.WriteString("})\n")

	buf.WriteString("netConfig.RegHttpRpc(map[uint16]netConfig.HttpRpc{\n")
	buf.WriteString(httpRpcs.String())
	buf.WriteString("})\n")

	buf.WriteString("netConfig.RegHttpPlayerRpc(map[uint16]netConfig.HttpPlayerRpc{\n")
	buf.WriteString(httpPlayerRpcs.String())
	buf.WriteString("})\n")

	buf.WriteString("netConfig.RegHttpHandler(map[string]netConfig.HttpHandle{\n")
	buf.WriteString(httpHandles.String())
	buf.WriteString("})\n")

	return buf.String()
}

// -------------------------------------
// -- 填充模板
const codeRegistTemplate = `
// Generated by GoServer/src/generat
// Don't edit !
package rpc
import (
	"netConfig"
	"generate/rpc/enum"
	{{range $k, $_ := .Moudles}}
	{{if eq $k "logic"}}
	"svr_{{$.Svr}}/{{$k}}"
	{{else}}
	"svr_{{$.Svr}}/logic/{{$k}}"
	{{end}}
	{{end}}
)
func init() {
{{.RegistList}}
}
`

type RpcInfo struct {
	Svr        string
	Moudles    map[string]bool
	RegistList string
}

func (self *RpcInfo) makeFile(svr string) {
	filename := K_RegistFileName
	tpl, err := template.New(filename).Parse(codeRegistTemplate)
	if err != nil {
		panic(err.Error())
		return
	}
	var bf bytes.Buffer
	if err = tpl.Execute(&bf, self); err != nil {
		panic(err.Error())
		return
	}
	if err := os.MkdirAll(K_RegistOutDir+svr, 0777); err != nil {
		panic(err.Error())
		return
	}
	f, err := os.OpenFile(K_RegistOutDir+svr+"/"+filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		panic(err.Error())
		return
	}
	defer f.Close()
	f.Write(bf.Bytes())
}
