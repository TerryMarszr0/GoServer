package main

import (
	"bytes"
	"common"
	"os"
	"text/template"
)

const (
	K_EnumOutDir   = K_OutDir + "enum/"
	K_EnumFileName = "generate_rpc_enum"
)

type TRpcCsv struct {
	Name     string
	ID       uint16
	IsClient int //是否Client实现的rpc
}

func generatRpcEnum() {
	var rpcList []TRpcCsv
	common.G_Csv_Map = map[string]interface{}{
		"rpc": &rpcList,
	}
	common.LoadAllCsv()
	rpcList = append(rpcList, TRpcCsv{"rpc_enum_cnt", uint16(len(rpcList))+1, 1})

	autoIncId := uint16(1)
	for i := 0; i < len(rpcList); i++ {
		csv := &rpcList[i]
		csv.ID = autoIncId
		autoIncId++
	}
	makeEnumFile_C(rpcList)
	makeEnumFile_Go(rpcList)
	makeEnumFile_CSharp(rpcList)
}

// -------------------------------------
// -- 填充模板 golang
const codeEnumTemplate1 = `
// Generated by GoServer/src/generat
// Don't edit !
package enum
const (
	{{range $_, $v := .}}{{RpcNameCapitalize $v.Name}} uint16 = {{$v.ID}}
	{{end}}
)
`

func makeEnumFile_Go(data interface{}) {
	filename := K_EnumFileName + ".go"
	var err error
	tpl := template.New(filename).Funcs(map[string]interface{}{
		"RpcNameCapitalize": RpcNameCapitalize,
	})
	if tpl, err = tpl.Parse(codeEnumTemplate1); err != nil {
		panic(err.Error())
		return
	}
	var bf bytes.Buffer
	if err = tpl.Execute(&bf, data); err != nil {
		panic(err.Error())
		return
	}
	if err = os.MkdirAll(K_EnumOutDir, 0777); err != nil {
		panic(err.Error())
		return
	}
	f, err := os.OpenFile(K_EnumOutDir+filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		panic(err.Error())
		return
	}
	defer f.Close()
	f.Write(bf.Bytes())
}
func RpcNameCapitalize(rpc string) string { return "R" + rpc[1:] }

// -------------------------------------
// -- 填充模板 c++
const codeEnumTemplate2 = `
// Generated by GoServer/src/generat
// Don't edit !
#define Rpc_Enum\
	{{range $_, $v := .}}_Declare({{$v.Name}}, {{$v.ID}})\
	{{end}}


#undef _Declare
#define _Declare(k, v) k = v,
enum RpcEnum:uint16 {
    Rpc_Enum
};
inline const char* RpcIdToName(int id) {
#ifdef _DEBUG
    static std::map<int, const char*> g_rpc_name;
    if (g_rpc_name.empty()) {
#undef _Declare
#define _Declare(k, v) g_rpc_name[v] = #k;
        Rpc_Enum
    }
    return g_rpc_name[id];
#else
    static char str[16];
    sprintf(str, "%d", id);
    return str;
#endif
}
`

func makeEnumFile_C(data interface{}) {
	filename := K_EnumFileName + ".h"
	tpl, err := template.New(filename).Parse(codeEnumTemplate2)
	if err != nil {
		panic(err.Error())
		return
	}
	var bf bytes.Buffer
	if err = tpl.Execute(&bf, data); err != nil {
		panic(err.Error())
		return
	}
	dir := K_EnumOutDir + "cpp/"
	if err = os.MkdirAll(dir, 0777); err != nil {
		panic(err.Error())
		return
	}
	f, err := os.OpenFile(dir+filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		panic(err.Error())
		return
	}
	defer f.Close()
	f.Write(bf.Bytes())
}

// -------------------------------------
// -- 填充模板 c#
const codeEnumTemplate3 = `
// Generated by GoServer/src/generat
// Don't edit !
public enum RpcEnum: System.UInt16 {
	{{range $_, $v := .}}{{$v.Name}} = {{$v.ID}},
	{{end}}
}
`

func makeEnumFile_CSharp(data interface{}) {
	filename := K_EnumFileName + ".cs"
	tpl, err := template.New(filename).Parse(codeEnumTemplate3)
	if err != nil {
		panic(err.Error())
		return
	}
	var bf bytes.Buffer
	if err = tpl.Execute(&bf, data); err != nil {
		panic(err.Error())
		return
	}
	dir := K_EnumOutDir + "cs/"
	if err = os.MkdirAll(dir, 0777); err != nil {
		panic(err.Error())
		return
	}
	f, err := os.OpenFile(dir+filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		panic(err.Error())
		return
	}
	defer f.Close()
	f.Write(bf.Bytes())
}
